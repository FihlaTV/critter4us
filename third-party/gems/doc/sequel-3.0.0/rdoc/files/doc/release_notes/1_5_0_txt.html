<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: 1.5.0.txt</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>1.5.0.txt</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>doc/release_notes/1.5.0.txt
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Jul 25 16:28:14 -0500 2009</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
You can now graph a dataset and have the result split into component
tables:
</p>
<pre>
  DB[:artists].graph(:albums, :artist_id=&gt;:id).first
  # =&gt; {:artists=&gt;{:id=&gt;artists.id, :name=&gt;artists.name}, \
  # :albums=&gt;{:id=&gt;albums.id, :name=&gt;albums.name,
</pre>
<p>
:artist_id=&gt;albums.artist_id}}
</p>
<p>
This aliases columns if necessary so they don&#8216;t stomp on each other,
which is what usually happens if you just join the tables:
</p>
<pre>
  DB[:artists].left_outer_join(:albums, :artist_id=&gt;:id).first
  # =&gt; {:id=&gt;(albums.id||artists.id),
</pre>
<p>
:name=&gt;(albums.name||artist.names), \
</p>
<pre>
        :artist_id=&gt;albums.artist_id}
</pre>
<p>
Models can use graph as well, in which case the values will be model
objects:
</p>
<pre>
  Artist.graph(Album, :artist_id=&gt;:id)
  # =&gt; {:artists=&gt;#&lt;Artist...&gt;, :albums=&gt;#&lt;Album...&gt;}
</pre>
<p>
Models can now eager load via .eager_graph, which will load all the results
and all associations in a single query. This is necessary if you want to
filter on columns in associated tables. It works exactly the same way as
.eager, and supports cascading of associations as well:
</p>
<pre>
  # Artist.one_to_many :albums
  # Album.one_to_many :tracks
  # Track.many_to_one :genre
  Artist.eager_graph(:albums=&gt;{:tracks=&gt;:genre}).filter( \
    :tracks_name=&gt;&quot;Firewire&quot;).all
</pre>
<p>
This will give you all artists have have an album with a track named
&quot;Firewire&quot;, and calling .albums on one of those artists will only
return albums that have a track named &quot;Firewire&quot;, and calling
.tracks on one of those albums will return only the track(s) named
&quot;Firewire&quot;.
</p>
<p>
You can use set_graph_aliases to select specific columns:
</p>
<pre>
  DB[:artists].graph(:albums, :artist_id=&gt;:id).set_graph_aliases( \
    :artist_name=&gt;[:artists, :name], :album_name=&gt;[:albums,
</pre>
<p>
:name]).first
</p>
<pre>
  # =&gt; {:artists=&gt;{:name=&gt;artists.name}, :albums=&gt;{:name=&gt;albums.name}}
</pre>
<p>
You can use eager_graph with set_graph_aliases to have eager loading with
control over the SELECT clause.
</p>
<p>
All associations now update their reciprocal associations whenever the
association methods are used, so you don&#8216;t need to refresh the
association or model to have the reciprocal association updated:
</p>
<pre>
  Album.many_to_one :band
  Band.one_to_many :albums

  # Note that all of these associations are cached,
  # so after the first access there are no additional
  # database queries to fetch associated records.

  # many_to_one setter adds to reciprocal association
  band1.albums # =&gt; []
  album1.band = band1
  band1.albums # =&gt; [album1]
  band2.albums # =&gt; []
  album1.band = band2
  band1.albums # =&gt; []
  band2.albums # =&gt; [album1]
  album1.band = band2
  band2.albums # =&gt; [album1]
  album1.band = nil
  band2.albums # =&gt; []

  # one_to_many add_* method sets reciprocal association
  # one_to_many remove_* method removes reciprocal association
  album1.band # =&gt; nil
  band1.add_album(album1)
  album1.band # =&gt; band1
  band2.add_album(album1)
  album1.band # =&gt; band2
  band2.remove_album(album1)
  album1.band # =&gt; nil

  Post.many_to_many :tags
  Tag.many_to_many :posts

  # many_to_many add_* method adds to reciprocal association
  # many_to_many remove_* method removes from reciprocal association
  post1.tags # =&gt; []
  tag1.posts # =&gt; []
  tag1.add_post(post1)
  post1.tags # =&gt; [tag1]
  tag1.posts # =&gt; [post1]
  tag1.remove_post(post1)
  post1.tags # =&gt; []
  tag1.posts # =&gt; []
  post1.add_tag(tag1)
  post1.tags # =&gt; [tag1]
  tag1.posts # =&gt; [post1]
  post1.remove_tag(tag1)
  post1.tags # =&gt; []
  tag1.posts # =&gt; []
</pre>
<p>
The MySQL and PostgreSQL adapters now support index types:
</p>
<pre>
  index :some_column, :type =&gt; :hash # or :spatial, :full_text, :rtree,
</pre>
<p>
etc.
</p>
<p>
Starting in <a href="../../../classes/Sequel.html">Sequel</a> 1.5.0, some
methods are deprecated. These methods will be removed in <a
href="../../../classes/Sequel.html">Sequel</a> 2.0.0. The deprecation
framework is fairly flexible. You can choose where the messages get sent:
</p>
<pre>
  Sequel::Deprecation.deprecation_message_stream = STDERR # the default
  Sequel::Deprecation.deprecation_message_stream = \
    File.new('deprecation.txt', 'wb') # A file
  Sequel::Deprecation.deprecation_message_stream = nil # ignore the
</pre>
<p>
messages
</p>
<p>
You can even have all deprecation messages accompanied by a traceback, so
you can see exactly where in your code you are using a deprecated method:
</p>
<pre>
  Sequel::Deprecation.print_tracebacks = true
</pre>
<p>
All deprecation methods come with an message telling you what alternative
code will work.
</p>
<p>
In addition to deprecating some methods, we removed the ability to have
arrays returned instead of hashes. The array code still had debugging
messages left it in, and we are not aware of anyone using it. Hashes have
been returned by default since <a
href="../../../classes/Sequel.html">Sequel</a> 0.3.
</p>
<p>
We have also removed the <a
href="../../../classes/Numeric.html">Numeric</a> date/time extensions (e.g.
3.days.ago). The existing extensions were incomplete, better ones are
provided elsewhere, and the extensions were not really related to <a
href="../../../classes/Sequel.html">Sequel</a>&#8216;s purpose.
</p>
<p>
<a href="../../../classes/Sequel.html">Sequel</a> no longer depends on
ParseTree, RubyInline, or ruby2ruby. They are still required to use the
block filters. <a href="../../../classes/Sequel.html">Sequel</a>&#8216;s
only gem dependency is on the tiny metaid.
</p>
<p>
<a href="../../../classes/Sequel.html">Sequel</a> 1.5.0 has fixes for 12
tracker issues, including fixes to the Informix, MySQL, ODBC, ADO, JDBC,
Postgres, and SQLite adapters.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>