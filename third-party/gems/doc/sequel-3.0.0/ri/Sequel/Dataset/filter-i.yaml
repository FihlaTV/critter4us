--- !ruby/object:RI::MethodDescription 
aliases: []

block_params: 
comment: 
- !ruby/struct:SM::Flow::P 
  body: Returns a copy of the dataset with the given conditions imposed upon it. If the query already has a HAVING clause, then the conditions are imposed in the HAVING clause. If not, then they are imposed in the WHERE clause.
- !ruby/struct:SM::Flow::P 
  body: "filter accepts the following argument types:"
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: Hash - list of equality/inclusion expressions
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: "Array - depends:"
  - !ruby/object:SM::Flow::LIST 
    contents: 
    - !ruby/struct:SM::Flow::LI 
      label: "*"
      body: If first member is a string, assumes the rest of the arguments are parameters and interpolates them into the string.
    - !ruby/struct:SM::Flow::LI 
      label: "*"
      body: If all members are arrays of length two, treats the same way as a hash, except it allows for duplicate keys to be specified.
    type: :BULLET
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: String - taken literally
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: Symbol - taken as a boolean column argument (e.g. WHERE active)
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: Sequel::SQL::BooleanExpression - an existing condition expression, probably created using the Sequel expression filter DSL.
  type: :BULLET
- !ruby/struct:SM::Flow::P 
  body: filter also takes a block, which should return one of the above argument types, and is treated the same way. This block yields a virtual row object, which is easy to use to create identifiers and functions.
- !ruby/struct:SM::Flow::P 
  body: If both a block and regular argument are provided, they get ANDed together.
- !ruby/struct:SM::Flow::P 
  body: "Examples:"
- !ruby/struct:SM::Flow::VERB 
  body: "  dataset.filter(:id =&gt; 3).sql #=&gt;\n    &quot;SELECT * FROM items WHERE (id = 3)&quot;\n  dataset.filter('price &lt; ?', 100).sql #=&gt;\n    &quot;SELECT * FROM items WHERE price &lt; 100&quot;\n  dataset.filter([[:id, (1,2,3)], [:id, 0..10]]).sql #=&gt;\n    &quot;SELECT * FROM items WHERE ((id IN (1, 2, 3)) AND ((id &gt;= 0) AND (id &lt;= 10)))&quot;\n  dataset.filter('price &lt; 100').sql #=&gt;\n    &quot;SELECT * FROM items WHERE price &lt; 100&quot;\n  dataset.filter(:active).sql #=&gt;\n    &quot;SELECT * FROM items WHERE :active\n  dataset.filter{|o| o.price &lt; 100}.sql #=&gt;\n    &quot;SELECT * FROM items WHERE (price &lt; 100)&quot;\n"
- !ruby/struct:SM::Flow::P 
  body: "Multiple filter calls can be chained for scoping:"
- !ruby/struct:SM::Flow::VERB 
  body: "  software = dataset.filter(:category =&gt; 'software')\n  software.filter{|o| o.price &lt; 100}.sql #=&gt;\n    &quot;SELECT * FROM items WHERE ((category = 'software') AND (price &lt; 100))&quot;\n"
- !ruby/struct:SM::Flow::P 
  body: See doc/dataset_filters.rdoc for more examples and details.
full_name: Sequel::Dataset#filter
is_singleton: false
name: filter
params: (*cond, &block)
visibility: public
